<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · JSON3.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>JSON3.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"><li><a class="toctext" href="#Builtin-types-1">Builtin types</a></li><li><a class="toctext" href="#Struct-API-1">Struct API</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul><a class="edit-page" href="https://github.com/quinnj/JSON3.jl/blob/master/docs/src/index.md#L"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="JSON3.jl-Documentation-1" href="#JSON3.jl-Documentation-1">JSON3.jl Documentation</a></h1><ul><li><a href="#JSON3.jl-Documentation-1">JSON3.jl Documentation</a></li><ul><li><a href="#Builtin-types-1">Builtin types</a></li><li><a href="#Struct-API-1">Struct API</a></li><ul><li><a href="#DataTypes-1">DataTypes</a></li><li><a href="#Interface-Types-1">Interface Types</a></li><ul><li><a href="#StructTypes.DictType-1">StructTypes.DictType</a></li><li><a href="#StructTypes.ArrayType-1">StructTypes.ArrayType</a></li><li><a href="#StructTypes.StringType-1">StructTypes.StringType</a></li><li><a href="#StructTypes.NumberType-1">StructTypes.NumberType</a></li><li><a href="#StructTypes.BoolType-1">StructTypes.BoolType</a></li><li><a href="#StructTypes.NullType-1">StructTypes.NullType</a></li></ul><li><a href="#AbstractTypes-1">AbstractTypes</a></li><li><a href="#Parametric-types-1">Parametric types</a></li></ul></ul></ul><h2><a class="nav-anchor" id="Builtin-types-1" href="#Builtin-types-1">Builtin types</a></h2><p>The JSON format is made up of just a few types: Object, Array, String, Number, Bool, and Null. In the JSON3 package, there are two main interfaces for interacting with these JSON types: 1) builtin and 2) struct mapping. For builtin reading, called like <code>JSON3.read(json_string)</code>, the JSON3 package will parse a string or <code>Vector{UInt8}</code>, returning a default object that maps to the type of the JSON. For a JSON Object, it will return a <code>JSON3.Object</code> type, which acts like an immutable <code>Dict</code>, but has a more efficient view representation. For a JSON Array, it will return a <code>JSON3.Array</code> type, which acts like an immutable <code>Vector</code>, but also has a more efficient view representation. If the JSON Array has homogenous elements, the resulting <code>JSON3.Array</code> will be strongly typed accordingly. For the other JSON types (string, number, bool, and null), they are returned as Julia equivalents (<code>String</code>, <code>Int64</code> or <code>Float64</code>, <code>Bool</code>, and <code>nothing</code>).</p><p>One might wonder why custom <code>JSON3.Object</code> and <code>JSON3.Array</code> types exist instead of just returning <code>Dict</code> and <code>Vector</code> directly. JSON3 employs a novel technique <a href="https://github.com/lemire/simdjson">inspired by the simdjson project</a>, that is a  semi-lazy parsing of JSON to the <code>JSON3.Object</code> or <code>JSON3.Array</code> types. The technique involves using a type-less &quot;tape&quot; to note the ***positions*** of objects, arrays, and strings in a JSON structure, while avoiding the cost of ***materializing*** such objects. For &quot;scalar&quot; types (number, bool, and null), the values are parsed immediately and stored inline in the &quot;tape&quot;. This can result in best of both worlds performance: very fast initial parsing of a JSON input, and very cheap access afterwards. It also enables efficiencies in workflows where only small pieces of a JSON structure are needed, because expensive objects, arrays, and strings aren&#39;t materialized unless accessed. One additional advantage this technique allows is strong typing of <code>JSON3.Array{T}</code>; because the type of each element is noted while parsing, the <code>JSON3.Array</code> object can then be constructed with the most narrow type possible without having to reallocate any underlying data (since all data is stored in a type-less &quot;tape&quot; anyway).</p><p>The <code>JSON3.Object</code> supports the <code>AbstactDict</code> interface, but is read-only (it represents a ***view*** into the JSON string input), thus it supports <code>obj[:x]</code> and <code>obj[&quot;x&quot;]</code>, as well as <code>obj.x</code> for accessing fields. It supports <code>keys(obj)</code> to see available keys in the object structure. You can call <code>length(obj)</code> to see how many key-value pairs there are, and it iterates <code>(k, v)</code> pairs like a normal <code>Dict</code>. It also supports the regular <code>get(obj, key, default)</code> family of methods. PLEASE NOTE that iterating key-value pairs from <code>JSON3.Object</code> will be much more performant than calling <code>getindex</code> or <code>get</code>on each key due to the internal &quot;view&quot; nature of the object.</p><p>The <code>JSON3.Array{T}</code> supports the <code>AbstractArray</code> interface, but like <code>JSON3.Object</code> is a ***view*** into the input JSON, hence is read-only. It supports normal array methods like <code>length(A)</code>, <code>size(A)</code>, iteration, and <code>A[i]</code> <code>getindex</code> methods. PLEASE NOTE that iterating a <code>JSON3.Array</code> will be much more performant than calling <code>getindex</code> on each index due to the internal &quot;view&quot; nature of the array.</p><h2><a class="nav-anchor" id="Struct-API-1" href="#Struct-API-1">Struct API</a></h2><p>The builtin JSON API in JSON3 is efficient and simple, but sometimes a direct mapping to a Julia structure is desirable. JSON3 uses the simple, yet powerful &quot;struct mapping&quot; techniques from the <a href="https://github.com/JuliaData/StructTypes.jl">StructTypes.jl</a> package.</p><p>In general, custom Julia types tend to be one of: 1) &quot;data types&quot;, 2) &quot;interface types&quot; and sometimes 3) &quot;abstract types&quot; with a known set of concrete subtypes. Data types tend to be &quot;collection of fields&quot; kind of types; fields are generally public and directly accessible, they might also be made to model &quot;objects&quot; in the object-oriented sense. In any case, the type is &quot;nominal&quot; in the sense that it&#39;s &quot;made up&quot; of the fields it has, sometimes even if just for making it more convenient to pass them around together in functions.</p><p>Interface types, on the other hand, are characterized by ***private*** fields; they contain optimized representations &quot;under the hood&quot; to provide various features/functionality and are useful via interface methods implemented: iteration, <code>getindex</code>, accessor methods, etc. Many package-provided libraries or Base-provided structures are like this: <code>Dict</code>, <code>Array</code>, <code>Socket</code>, etc. For these types, their underlying fields are mostly cryptic and provide little value to users directly, and are often explictly documented as being implementation details and not to be accessed under warning of breakage.</p><p>What does all this have to do with mapping Julia structures to JSON? A lot! For data types, the most typical JSON representation is for each field name to be a JSON key, and each field value to be a JSON value. And when ***reading*** data types from JSON, we need to specify how to construct the Julia structure for the key-value pairs encountered while parsing. This can be considered a &quot;direct&quot; mapping of Julia struct types to JSON objects in that we try to map field to key directly. This is the &quot;data type&quot; view of json-to-Julia struct mapping.</p><p>For interface types, however, we don&#39;t want to consider the type&#39;s fields at all, since they&#39;re &quot;private&quot; and not very meaningful. For these types, an alternative API is provided where a user can specify the <code>StructTypes.StructType</code> their type most closely maps to, one of <code>StructTypes.DictType()</code>, <code>StructTypes.ArrayType()</code>, <code>StructTypes.StringType()</code>, <code>StructTypes.NumberType()</code>, <code>StructTypes.BoolType()</code>, or <code>StructTypes.NullType()</code>.</p><p>For abstract types, it can sometimes be useful when reading a JSON structure to say that it will be one of a limited set of related types, with a specific JSON key in the structure signaling which concrete type the rest of the structure represents. JSON3 uses StructTypes.jl functionality to specify a <code>StructTypes.AbstractType()</code> for a type, along with a mapping of JSON key-type values to Julia subtypes that can be used to identify the concrete type while parsing.</p><h3><a class="nav-anchor" id="DataTypes-1" href="#DataTypes-1">DataTypes</a></h3><p>For &quot;data types&quot;, we aim to directly specify the JSON reading/writing behavior with respect to a Julia type&#39;s fields. This kind of data type can signal its struct type in one of two ways:</p><pre><code class="language-julia">StructTypes.StructType(::Type{MyType}) = StructTypes.Struct()
# or
StructTypes.StructType(::Type{MyType}) = StructTypes.Mutable()</code></pre><p><code>StructTypes.Struct()</code> is less flexible, yet more performant. For reading a <code>StructTypes.Struct()</code> from a JSON string input, each key-value pair is read in the order it is encountered in the JSON input, the keys are ignored, and the values are directly passed to the type at the end of the object parsing like <code>MyType(val1, val2, val3)</code>. Yes, the JSON specification says that Objects are specifically ***un-ordered*** collections of key-value pairs, but the truth is that many JSON libraries provide ways to maintain JSON Object key-value pair order when reading/writing. Because of the minimal processing done while parsing, and the &quot;trusting&quot; that the Julia type constructor will be able to handle fields being present, missing, or even extra fields that should be ignored, this is the fastest possible method for mapping a JSON input to a Julia structure. If your workflow interacts with non-Julia APIs for sending/receiving JSON, you should take care to test and confirm the use of <code>StructTypes.Struct()</code> in the cases mentioned above: what if a field is missing when parsing? what if the key-value pairs are out of order? what if there extra fields get included that weren&#39;t anticipated? If your workflow is questionable on these points, or it would be too difficult to account for these scenarios in your type constructor, it would be better to consider the <code>StructTypes.Mutable()</code> option.</p><p>The slightly less performant, yet much more robust method for directly mapping Julia struct fields to JSON objects is via <code>StructTypes.Mutable()</code>. This technique requires your Julia type to be defined, ***at a minimum***, like:</p><pre><code class="language-julia">mutable struct MyType
    field1
    field2
    field3
    # etc.

    MyType() = new()
end</code></pre><p>Note specifically that we&#39;re defining a <code>mutable struct</code> to allow field mutation, and providing a <code>MyType() = new()</code> inner constructor which constructs an &quot;empty&quot; <code>MyType</code> where isbits fields will be randomly initialied, and reference fields will be <code>#undef</code>. (Note that the inner constructor doesn&#39;t need to be ***exactly*** this, but at least needs to be callable like <code>MyType()</code>. If certain fields need to be intialized or zeroed out for security, then this should be accounted for in the inner constructor). For these mutable types, the type will first be initizlied like <code>MyType()</code>, then JSON parsing will parse each key-value pair in a JSON object, setting the field as the key is encountered, and converting the JSON value to the appropriate field value. This flow has the nice properties of: allowing parsing success even if fields are missing in the JSON structure, and if &quot;extra&quot; fields exist in the JSON structure that aren&#39;t apart of the Julia struct&#39;s fields, it will automatically be ignored. This allows for maximum robustness when mapping Julia types to arbitrary JSON objects that may be generated via web services, other language JSON libraries, etc.</p><p>There are a few additional helper methods that can be utilized by <code>StructTypes.Mutable()</code> types to hand-tune field reading/writing behavior:</p><ul><li><code>StructTypes.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))</code>: provides a mapping of Julia field name to expected JSON object key name. This affects both reading and writing. When reading the <code>json1</code> key, the <code>field1</code> field of <code>MyType</code> will be set. When writing the <code>field2</code> field of <code>MyType</code>, the JSON key will be <code>json2</code>.</li><li><code>StructTypes.excludes(::Type{MyType}) = (:field1, :field2)</code>: specify fields of <code>MyType</code> to ignore when reading and writing, provided as a <code>Tuple</code> of <code>Symbol</code>s. When reading, if <code>field1</code> is encountered as a JSON key, it&#39;s value will be read, but the field will not be set in <code>MyType</code>. When writing, <code>field1</code> will be skipped when writing out <code>MyType</code> fields as key-value pairs.</li><li><code>StructTypes.omitempties(::Type{MyType}) = (:field1, :field2)</code>: specify fields of <code>MyType</code> that shouldn&#39;t be written if they are &quot;empty&quot;, provided as a <code>Tuple</code> of <code>Symbol</code>s. This only affects writing. If a field is a collection (AbstractDict, AbstractArray, etc.) and <code>isempty(x) === true</code>, then it will not be written. If a field is <code>#undef</code>, it will not be written. If a field is <code>nothing</code>, it will not be written. </li><li><code>StructTypes.keywordargs(::Type{MyType}) = (field1=(dateformat=dateformat&quot;mm/dd/yyyy&quot;,), field2=(dateformat=dateformat&quot;HH MM SS&quot;,))</code>: Specify for a <code>StructTypes.Mutable</code> <code>StructType</code> the keyword arguments by field, given as a <code>NamedTuple</code> of <code>NamedTuple</code>s, that should be passed</li></ul><p>to the <code>StructTypes.construct</code> method when deserializing <code>MyType</code>. This essentially allows defining specific keyword arguments you&#39;d like to be passed for each field in your struct. Note that keyword arguments can be passed when reading, like <code>JSON3.read(source, MyType; dateformat=...)</code> and they will be passed down to each <code>StructTypes.construct</code> method. <code>StructTypes.keywordargs</code> just allows the defining of specific keyword arguments per field.</p><h3><a class="nav-anchor" id="Interface-Types-1" href="#Interface-Types-1">Interface Types</a></h3><p>For interface types, we don&#39;t want the internal fields of a type exposed, so an alternative API is to define the closest JSON type that our custom type should map to. This is done by choosing one of the following definitions:</p><pre><code class="language-julia">StructTypes.StructType(::Type{MyType}) = StructTypes.DictType()
StructTypes.StructType(::Type{MyType}) = StructTypes.ArrayType()
StructTypes.StructType(::Type{MyType}) = StructTypes.StringType()
StructTypes.StructType(::Type{MyType}) = StructTypes.NumberType()
StructTypes.StructType(::Type{MyType}) = StructTypes.BoolType()
StructTypes.StructType(::Type{MyType}) = StructTypes.NullType()</code></pre><p>Now we&#39;ll walk through each of these and what it means to map my custom Julia type to an interface type.</p><h4><a class="nav-anchor" id="StructTypes.DictType-1" href="#StructTypes.DictType-1">StructTypes.DictType</a></h4><pre><code class="language-none">StructTypes.StructType(::Type{MyType}) = StructTypes.DictType()</code></pre><p>Declaring my type is <code>StructTypes.DictType()</code> means it should map to a JSON object of unordered key-value pairs, where keys are <code>Symbol</code> or <code>String</code>, and values are any other type (or <code>Any</code>).</p><p>Types already declared as <code>StructTypes.DictType()</code> include:</p><ul><li>Any subtype of <code>AbstractDict</code></li><li>Any <code>NamedTuple</code> type</li><li>Any <code>Pair</code> type</li></ul><p>So if your type subtypes <code>AbstractDict</code> and implements its interface, then JSON reading/writing should just work!</p><p>Otherwise, the interface to satisfy <code>StructTypes.DictType()</code> for reading is:</p><ul><li><code>MyType(x::Dict{Symbol, Any})</code>: implement a constructor that takes a <code>Dict{Symbol, Any}</code> of key-value pairs parsed from JSOn</li><li><code>StructTypes.construct(::Type{MyType}, x::Dict; kw...)</code>: alternatively, you may overload the <code>StructTypes.construct</code> method for your type if defining a constructor is undesirable (or would cause other clashes or ambiguities)</li></ul><p>The interface to satisfy for writing is:</p><ul><li><code>pairs(x)</code>: implement the <code>pairs</code> iteration function (from Base) to iterate key-value pairs to be written out to JSON</li><li><code>StructTypes.keyvaluepairs(x::MyType)</code>: alternatively, you can overload the <code>StructTypes.keyvaluepairs</code> function if overloading <code>pairs</code> isn&#39;t possible for whatever reason</li></ul><h4><a class="nav-anchor" id="StructTypes.ArrayType-1" href="#StructTypes.ArrayType-1">StructTypes.ArrayType</a></h4><pre><code class="language-none">StructTypes.StructType(::Type{MyType}) = StructTypes.ArrayType()</code></pre><p>Declaring my type is <code>StructTypes.ArrayType()</code> means it should map to a JSON array of ordered elements, homogenous or otherwise.</p><p>Types already declared as <code>StructTypes.ArrayType()</code> include:</p><ul><li>Any subtype of <code>AbstractArray</code></li><li>Any subtype of <code>AbstractSet</code></li><li>Any <code>Tuple</code> type</li></ul><p>So if your type already subtypes these and satifies the interface, things should just work.</p><p>Otherwise, the interface to satisfy <code>StructTypes.ArrayType()</code> for reading is:</p><ul><li><code>MyType(x::Vector)</code>: implement a constructo that takes a <code>Vector</code> argument of values and constructs a <code>MyType</code></li><li><code>StructTypes.construct(::Type{MyType}, x::Vector; kw...)</code>: alternatively, you may overload the <code>StructTypes.construct</code> method for your type if defining a constructor isn&#39;t possible</li><li>Optional: <code>Base.IteratorEltype(::Type{MyType})</code> and <code>Base.eltype(x::MyType)</code>: this can be used to signal to JSON3 that elements for your type are expected to be a single type and JSON3 will attempt to parse as such</li></ul><p>The interface to satisfy for writing is:</p><ul><li><code>iterate(x::MyType)</code>: just iteration over each element is required; note if you subtype <code>AbstractArray</code> and define <code>getindex(x::MyType, i::Int)</code>, then iteration is already defined for your type</li></ul><h4><a class="nav-anchor" id="StructTypes.StringType-1" href="#StructTypes.StringType-1">StructTypes.StringType</a></h4><pre><code class="language-none">StructTypes.StructType(::Type{MyType}) = StructTypes.StringType()</code></pre><p>Declaring my type is <code>StructTypes.StringType()</code> means it should map to a JSON string value.</p><p>Types already declared as <code>StructTypes.StringType()</code> include:</p><ul><li>Any subtype of <code>AbstractString</code></li><li>The <code>Symbol</code> type</li><li>Any subtype of <code>Enum</code> (values are written with their symbolic name)</li><li>The <code>Char</code> type</li></ul><p>So if your type is an <code>AbstractString</code> or <code>Enum</code>, then things should already work.</p><p>Otherwise, the interface to satisfy <code>StructTypes.StringType()</code> for reading is:</p><ul><li><code>MyType(x::String)</code>: define a constructor for your type that takes a single String argument</li><li><code>StructTypes.construct(::Type{MyType}, x::String; kw...)</code>: alternatively, you may overload <code>StructTypes.construct</code> for your type</li><li><code>StructTypes.construct(::Type{MyType}, ptr::Ptr{UInt8}, len::Int; kw...)</code>: another option is to overload <code>StructTypes.construct</code> with pointer and length arguments, if it&#39;s possible for your custom type to take advantage of avoiding the full string materialization; note that your type should implement both <code>StructTypes.construct</code> methods, since JSON strings with escape characters in them will be fully unescaped before calling <code>StructTypes.construct(::Type{MyType}, x::String)</code>, i.e. there is no direct pointer/length method for escaped strings</li></ul><p>The interface to satisfy for writing is:</p><ul><li><code>Base.string(x::MyType)</code>: overload <code>Base.string</code> for your type to return a &quot;stringified&quot; value</li></ul><h4><a class="nav-anchor" id="StructTypes.NumberType-1" href="#StructTypes.NumberType-1">StructTypes.NumberType</a></h4><pre><code class="language-none">StructTypes.StructType(::Type{MyType}) = StructTypes.NumberType()</code></pre><p>Declaring my type is <code>StructTypes.NumberType()</code> means it should map to a JSON number value.</p><p>Types already declared as <code>StructTypes.NumberType()</code> include:</p><ul><li>Any subtype of <code>Signed</code></li><li>Any subtype of <code>Unsigned</code></li><li>Any subtype of <code>AbstractFloat</code></li></ul><p>In addition to declaring <code>StructTypes.NumberType()</code>, custom types can also specify a specific, ***existing*** number type it should map to. It does this like:</p><pre><code class="language-julia">StructTypes.numbertype(::Type{MyType}) = Float64</code></pre><p>In this case, I&#39;m declaring the <code>MyType</code> should map to an already-supported number type <code>Float64</code>. This means that when reading, JSON3 will first parse a <code>Float64</code> value, and then call <code>MyType(x::Float64)</code>. Note that custom types may also overload <code>StructTypes.construct(::Type{MyType}, x::Float64; kw...)</code> if using a constructor isn&#39;t possible. Also note that the default for any type declared as <code>StructTypes.NumberType()</code> is <code>Float64</code>.</p><p>Similarly for writing, JSON3 will first call <code>Float64(x::MyType)</code> before writing the resulting <code>Float64</code> value out as a JSON number.</p><h4><a class="nav-anchor" id="StructTypes.BoolType-1" href="#StructTypes.BoolType-1">StructTypes.BoolType</a></h4><pre><code class="language-none">StructTypes.StructType(::Type{MyType}) = StructTypes.BoolType()</code></pre><p>Declaring my type is <code>StructTypes.BoolType()</code> means it should map to a JSON boolean value.</p><p>Types already declared as <code>StructTypes.BoolType()</code> include:</p><ul><li><code>Bool</code></li></ul><p>The interface to satisfy for reading is:</p><ul><li><code>MyType(x::Bool)</code>: define a constructor that takes a single <code>Bool</code> value</li><li><code>StructTypes.construct(::Type{MyType}, x::Bool; kw...)</code>: alternatively, you may overload <code>StructTypes.construct</code></li></ul><p>The interface to satisfy for writing is:</p><ul><li><code>Bool(x::MyType)</code>: define a conversion to <code>Bool</code> method</li></ul><h4><a class="nav-anchor" id="StructTypes.NullType-1" href="#StructTypes.NullType-1">StructTypes.NullType</a></h4><pre><code class="language-none">StructTypes.StructType(::Type{MyType}) = StructTypes.NullType()</code></pre><p>Declaring my type is <code>StructTypes.NullType()</code> means it should map to the JSON value <code>null</code>.</p><p>Types already declared as <code>StructTypes.NullType()</code> include:</p><ul><li><code>nothing</code></li><li><code>missing</code></li></ul><p>The interface to satisfy for reading is:</p><ul><li><code>MyType()</code>: an empty constructor for <code>MyType</code></li><li><code>StructTypes.construct(::Type{MyType}, x::Nothing; kw...)</code>: alternatively, you may overload <code>StructTypes.construct</code></li></ul><p>There is no interface for writing; if a custom type is declared as <code>StructTypes.NullType()</code>, then the JSON value <code>null</code> will be written.</p><h3><a class="nav-anchor" id="AbstractTypes-1" href="#AbstractTypes-1">AbstractTypes</a></h3><p>A final, uncommon option for struct mapping is declaring:</p><pre><code class="language-julia">StructTypes.StructType(::Type{MyType}) = StructTypes.AbstractType()</code></pre><p>When declaring my type as <code>StructTypes.AbstractType()</code>, you must also define <code>StructTypes.subtypes</code>, which should be a NamedTuple with subtype keys mapping to Julia subtype Type values. You may optionally define <code>StructTypes.subtypekey</code> that indicates which JSON key should be used for identifying the appropriate concrete subtype. A quick example should help illustrate proper use of this <code>StructType</code>:</p><pre><code class="language-julia">abstract type Vehicle end

struct Car &lt;: Vehicle
    type::String
    make::String
    model::String
    seatingCapacity::Int
    topSpeed::Float64
end

struct Truck &lt;: Vehicle
    type::String
    make::String
    model::String
    payloadCapacity::Float64
end

StructTypes.StructType(::Type{Vehicle}) = StructTypes.AbstractType()
StructTypes.StructType(::Type{Car}) = StructTypes.Struct()
StructTypes.StructType(::Type{Truck}) = StructTypes.Struct()
StructTypes.subtypekey(::Type{Vehicle}) = :type
StructTypes.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)

car = JSON3.read(&quot;&quot;&quot;
{
    &quot;type&quot;: &quot;car&quot;,
    &quot;make&quot;: &quot;Mercedes-Benz&quot;,
    &quot;model&quot;: &quot;S500&quot;,
    &quot;seatingCapacity&quot;: 5,
    &quot;topSpeed&quot;: 250.1
}&quot;&quot;&quot;, Vehicle)</code></pre><p>Here we have a <code>Vehicle</code> type that is defined as a <code>StructTypes.AbstractType()</code>. We also have two concrete subtypes, <code>Car</code> and <code>Truck</code>. In addition to the <code>StructType</code> definition, we also define <code>StructTypes.subtypekey(::Type{Vehicle}) = :type</code>, which signals to JSON3 that, when parsing a JSON structure, when it encounters the <code>type</code> key, it should use the value, in our example it&#39;s <code>car</code>, to discover the appropriate concrete subtype to parse the structure as, in this case <code>Car</code>. The mapping of JSON subtype key value to Julia Type is defined in our example via <code>StructTypes.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)</code>. Thus, <code>StructTypes.AbstractType</code> is useful when the JSON structure to read includes a &quot;subtype&quot; key-value pair that can be used to parse a specific, concrete type; in our example, parsing the structure as a <code>Car</code> instead of a <code>Truck</code>.</p><h3><a class="nav-anchor" id="Parametric-types-1" href="#Parametric-types-1">Parametric types</a></h3><p>When using parametric types define the <code>StructTypes.StructType</code> for all the subtypes of your parametric type:</p><pre><code class="language-julia">struct MyParametricType{T}
    t::T
    MyParametricType{T}(t) where {T} = new(t)
end
MyParametricType(t::T) where {T} = MyParametricType{T}(t)

x = MyParametricType(1)

StructTypes.StructType(::Type{&lt;:MyParametricType}) = StructTypes.Struct() # note the `&lt;:`
                                                              # NOT like this StructTypes.StructType(::Type{MyParametricType})</code></pre><footer><hr/></footer></article></body></html>
